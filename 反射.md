### 什么是反射
反射是指再程序运行期对程序本身进行访问喝修改的能力。在程序编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。

支持反射的语言可以在程序编译器将变量的反射信息，如字段名，类型信息，接口提信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并有能力修改它们。


### reflect包
在go语言的反射机制中，任何接口都由 **一个具体类型** 和 **具体类型的值**两部分组成的。`reflect`包提供了 `reflect.TypeOf` 和 `reflect.ValueOf`两个函数来获取任意对象的value和type。

```go
package main

import (
	"fmt"
	"reflect"
)

func reflectType(x interface{}) {
	v := reflect.TypeOf(x)
	fmt.Printf("type: %v\n", v)
}

func main() {
	 a := 3.14
	 reflectType(a)      //type:float64
	 var b int64 = 100
	 reflectType(b)     //type:int64
}
```

#### type.Name() 和 type.Kind()
```go
package main

import (
	"fmt"
	"reflect"
)

type MyInt int64

type Mystr = string

func reflectType(x interface{}) {
	v := reflect.TypeOf(x)
	fmt.Printf("type name: %v, type kind:%v\n", v.Name(), v.Kind())
}

func main() {
	var a *float32
	var b MyInt
	var c rune
	var d byte
	var e Mystr

	reflectType(a)	//type name: , type kind:ptr
	reflectType(b)	//MyInt, type kind:int64
	reflectType(c)	//type name: int32, type kind:int32
	reflectType(d)	//type name: uint8, type kind:uint8
	reflectType(e)	//type name: string, type kind:string

	f:= struct {
		Name string
		Age int
	}{"zzz", 19}
	reflectType(f)	//type name: , type kind:struct
}

```

#### ValueOf
`reflect.Value()`返回的是`reflect.Value`类型，其中包含了原始值的值信息。`reflect.Value`与原始值之间可以互相转换。

`reflect.Value`类型提供了如下获取原始值的方法：

|方法接收者|实现接口的类型
|---|---
|Interface() interface {} | 将值以interface{}类型返回，可以通过类型断言转换为指定类型
|Int() int64|将值以 int 类型返回，所有有符号整型均可以此方式返回
|Uint() uint64	|将值以 uint 类型返回，所有无符号整型均可以此方式返回
|Float() float64|将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回
|Bool() bool	|将值以 bool 类型返回
|Bytes() []bytes	|将值以字节数组 []bytes 类型返回
|String() string	|将值以字符串类型返回

> 通过反射获取值
```go
func reflectValue(x interface{}) {
	v := reflect.ValueOf(x)
	k := v.Kind()
	switch k {
	case reflect.Int64:
		// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换
		fmt.Printf("type is int64, value is %d\n", int64(v.Int()))
	case reflect.Float32:
		// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换
		fmt.Printf("type is float32, value is %f\n", float32(v.Float()))
	case reflect.Float64:
		// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换
		fmt.Printf("type is float64, value is %f\n", float64(v.Float()))
	}
}
func main() {
	var a float32 = 3.14
	var b int64 = 100
	reflectValue(a) // type is float32, value is 3.140000
	reflectValue(b) // type is int64, value is 100
	// 将int类型的原始值转换为reflect.Value类型
	c := reflect.ValueOf(10)
	fmt.Printf("type c :%T\n", c) // type c :reflect.Value
}
```

> 通过反射设置变量的值
```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var i int64 = 100
	v := reflect.ValueOf(&i)
	//v1 := reflect.ValueOf(i)
	v.Elem().SetInt(10)
	//v1.Elem().SetInt(11)
	fmt.Println(i)
}
```

1.调用`reflect.ValueOf`获取变量指针；
2.调用 `reflect.Value.Elem` 获取指针指向的变量；
3.调用 `reflect.Value.SetInt` 更新变量的值;

### Reference 
https://mp.weixin.qq.com/s/nlcam7jJxbJRrmOvUWkAOA