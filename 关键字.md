### iota
`iota`是go语言的常量计数器，只能用于常量表达式中。

`iota`在`const`关键字出现时会被重置为`0`。`const`中每新增一行常量声明将使`iota`计数一次。（常用于枚举）

```go
const (
	N1 = iota   //0
	N2          //1
	N3          //2
	N4          //3
)

```

使用`_`跳过计数：

```go
const (
	N1 = iota   //1
    N2          //2
	_
	N4          //3
)
```

多个iota定义在一行:
```go
const (
		a, b = iota + 1, iota + 2 //1,2
		c, d                      //2,3
		e, f                      //3,4
	)
```

`iota`声明中间插队：
```go
const (
		n1 = iota //0
		n2 = 100  //100
		n3 = iota //2
		n4        //3
	)
	const n5 = iota //0
```

### defer
`defer`会将其后面跟随的语句或函数进行延迟处理。defer注册要延迟执行的函数时该函数所有的参数都需要确定其值。

```go
func main() {
    defer fmt.Println("The third line.")
    defer fmt.Println("The second line.")
    fmt.Println("The first line.")
}

//输出
//The first line.
//The second line.
//The third line.
```

当一个函数调用被延迟后，它不会立即被执行。它将被推入由当前协程维护的一个延迟调用堆栈。 当一个函数调用（可能是也可能不是一个延迟调用）返回并进入它的退出阶段后，所有在此函数调用中已经被推入的延迟调用将被按照它们被推入堆栈的顺序逆序执行。 当所有这些延迟调用执行完毕后，此函数调用也就真正退出了。

事实上，每个协程维护着两个调用堆栈。
- 一个是正常的函数调用堆栈。在此堆栈中，相邻的两个调用存在着调用关系。晚进入堆栈的调用被早进入堆栈的调用所调用。 此堆栈中最早被推入的调用是对应协程的启动调用。
- 另一个堆栈是上面提到的延迟调用堆栈。处于延迟调用堆栈中的任意两个调用之间不存在调用关系。
